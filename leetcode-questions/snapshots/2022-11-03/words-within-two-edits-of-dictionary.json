{
  "id": "words-within-two-edits-of-dictionary",
  "name": "Words Within Two Edits of Dictionary",
  "tags": [
    "Array",
    "String"
  ],
  "description": "You are given two string arrays, queries and dictionary. All words in each array comprise of lowercase English letters and have the same length.\n\nIn one edit you can take a word from queries, and change any letter in it to any other letter. Find all words from queries that, after a maximum of two edits, equal some word from dictionary.\n\nReturn a list of all words from queries, that match with some word from dictionary after a maximum of two edits. Return the words in the same order they appear in queries.\n\n \nExample 1:\n\nInput: queries = [\"word\",\"note\",\"ants\",\"wood\"], dictionary = [\"wood\",\"joke\",\"moat\"]\nOutput: [\"word\",\"note\",\"wood\"]\nExplanation:\n- Changing the 'r' in \"word\" to 'o' allows it to equal the dictionary word \"wood\".\n- Changing the 'n' to 'j' and the 't' to 'k' in \"note\" changes it to \"joke\".\n- It would take more than 2 edits for \"ants\" to equal a dictionary word.\n- \"wood\" can remain unchanged (0 edits) and match the corresponding dictionary word.\nThus, we return [\"word\",\"note\",\"wood\"].\n\n\nExample 2:\n\nInput: queries = [\"yes\"], dictionary = [\"not\"]\nOutput: []\nExplanation:\nApplying any two edits to \"yes\" cannot make it equal to \"not\". Thus, we return an empty array.\n\n\n \nConstraints:\n\n\n\t1 <= queries.length, dictionary.length <= 100\n\tn == queries[i].length == dictionary[j].length\n\t1 <= n <= 100\n\tAll queries[i] and dictionary[j] are composed of lowercase English letters.\n\n"
}