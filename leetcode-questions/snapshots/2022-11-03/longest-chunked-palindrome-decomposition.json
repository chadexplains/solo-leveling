{
  "id": "longest-chunked-palindrome-decomposition",
  "name": "Longest Chunked Palindrome Decomposition",
  "tags": [
    "Two Pointers",
    "String",
    "Dynamic Programming",
    "Greedy",
    "Rolling Hash",
    "Hash Function"
  ],
  "description": "You are given a string text. You should split it to k substrings (subtext1, subtext2, ..., subtextk) such that:\n\n\n\tsubtexti is a non-empty string.\n\tThe concatenation of all the substrings is equal to text (i.e., subtext1 + subtext2 + ... + subtextk == text).\n\tsubtexti == subtextk - i + 1 for all valid values of i (i.e., 1 <= i <= k).\n\n\nReturn the largest possible value of k.\n\n \nExample 1:\n\nInput: text = \"ghiabcdefhelloadamhelloabcdefghi\"\nOutput: 7\nExplanation: We can split the string on \"(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)\".\n\n\nExample 2:\n\nInput: text = \"merchant\"\nOutput: 1\nExplanation: We can split the string on \"(merchant)\".\n\n\nExample 3:\n\nInput: text = \"antaprezatepzapreanta\"\nOutput: 11\nExplanation: We can split the string on \"(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)\".\n\n\n \nConstraints:\n\n\n\t1 <= text.length <= 1000\n\ttext consists only of lowercase English characters.\n\n"
}