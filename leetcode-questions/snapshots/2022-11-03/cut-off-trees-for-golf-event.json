{
  "id": "cut-off-trees-for-golf-event",
  "name": "Cut Off Trees for Golf Event",
  "tags": [
    "Array",
    "Breadth-First Search",
    "Heap (Priority Queue)",
    "Matrix"
  ],
  "description": "You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an m x n matrix. In this matrix:\n\n\n\t0 means the cell cannot be walked through.\n\t1 represents an empty cell that can be walked through.\n\tA number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree's height.\n\n\nIn one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.\n\nYou must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes 1 (an empty cell).\n\nStarting from the point (0, 0), return the minimum steps you need to walk to cut off all the trees. If you cannot cut off all the trees, return -1.\n\nNote: The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.\n\n \nExample 1:\n\nInput: forest = [[1,2,3],[0,0,4],[7,6,5]]\nOutput: 6\nExplanation: Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\n\n\nExample 2:\n\nInput: forest = [[1,2,3],[0,0,0],[7,6,5]]\nOutput: -1\nExplanation: The trees in the bottom row cannot be accessed as the middle row is blocked.\n\n\nExample 3:\n\nInput: forest = [[2,3,4],[0,0,5],[8,7,6]]\nOutput: 6\nExplanation: You can follow the same path as Example 1 to cut off all the trees.\nNote that you can cut off the first tree at (0, 0) before making any steps.\n\n\n \nConstraints:\n\n\n\tm == forest.length\n\tn == forest[i].length\n\t1 <= m, n <= 50\n\t0 <= forest[i][j] <= 109\n\tHeights of all trees are distinct.\n\n"
}